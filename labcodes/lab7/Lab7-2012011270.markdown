# Lab7 report
>* 熟悉ucore中的进程同步机制，了解操作系统为进程同步提供的底层支持；
>* 在ucore中理解信号量（semaphore）机制的具体实现；
>* 理解管程机制，在ucore内核中增加基于管程（monitor）的条件变量（condition variable）的支持；
>* 了解经典进程同步问题，并能使用同步机制解决进程同步问题。

标签（空格分隔）： ucore-lab

---

## 练习0：填写已有实验

本实验依赖实验1/2/3/4/5/6。请把你做的实验1/2/3/4/5/6的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab7的测试应用程序，可能需对已完成的实验1/2/3/4/5/6的代码进行进一步改进。
> 答：已完成。
## [练习1]
理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

1-1 请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。
```
内核级信号量即是semaphor_t。
相关操作有以下几种：
sema_init:初始化函数，设定一个某初始值的信号量。
V操作：up:查找是否存在进程处于等待状态，如果有则唤醒一个，否则信号量的值增加1
local_intr_save……local_intr_store，这说明这段过程是不能被中断的，保证了这段程序的原子性。
P操作：down:查看信号量的值是否为正数，如果是则减1，否则进入等待队列并进行一次调度。
try_down:只检查信号量的值是否为正数，如果是则减1。
```

1-2 请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。
```
用户态没有办法关闭中断，使用系统调用的方法来使用户态进程可以使用信号量机制，使用一些指令系统中的原子操作设计面向用户态进程的信号量机制。如果要给用户态进程提供信号量操作，因为down和up中都有调用调度器，必须要在内核态执行，所以可以新建系统调用如sys_down和sys_up用来申请资源和释放资源，在中断处理函数中调用内核态的函数。
```

## [练习2]
首先掌握管程机制，然后基于信号量实现完成条件变量实现，然后用管程机制实现哲学家就餐问题的解决方案（基于条件变量）。
执行：make grade 。如果所显示的应用程序检测都输出ok，则基本正确。如果只是某程序过不去，比如matrix.c，则可执行 make run-matrix 命令来单独调试它。大致执行结果可看附录。（使用的是qemu-1.0.1）。

2-1 请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程。
```
内核级条件变量即是condvar_t，
包含一个信号量sem，一个等待计数器，和一个monitor指针，
monitor中有2个信号量mutex和next。
mutex用于对monitor加锁。
next用于协调wait proc和signal proc。
相关操作有：
monitor_init:初始化函数，mutex初始为1，即状态为无锁，next初始为0
cond_signal:检查等待计数器是否为正数确定是否有等待进程，如果有的话释放monitor的锁，并试图获取next锁
cond_wait:检测是否有等待被唤醒的进程，如果有的话唤醒它，否则释放monitor的锁，并试图获取条件变量的信号量
```

2-2 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。
```
用户态没有办法关闭中断，可以使用系统调用的方法或原子操作设计条件变量。
```

## [与参考答案的区别]
```
思路上没有太大区别，实现上有所区别。
```

## [实验中重要的知识点]
```
信号量。
条件变量。
哲学家就餐。
```